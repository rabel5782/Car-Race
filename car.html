<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Car Racing Game</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
    #loading {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-family: Arial, sans-serif;
      font-size: 20px;
    }
  </style>
</head>
<body>
  <div id="loading">Loading 3D Car...</div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/loaders/GLTFLoader.js"></script>

  <script>
    let scene, camera, renderer, car, road;
    let speed = 0.3;
    const buildings = [];
    const streetLights = [];
    const trafficLights = [];

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x202020);

      // Camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2, 5);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Lighting
      const ambient = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambient);

      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(10, 20, 0);
      scene.add(dirLight);

      // Road
      const roadGeo = new THREE.PlaneGeometry(10, 500);
      const roadMat = new THREE.MeshPhongMaterial({ color: 0x404040 });
      road = new THREE.Mesh(roadGeo, roadMat);
      road.rotation.x = -Math.PI / 2;
      scene.add(road);

      // Center line
      const lineGeo = new THREE.PlaneGeometry(0.2, 500);
      const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const line = new THREE.Mesh(lineGeo, lineMat);
      line.position.y = 0.01;
      line.rotation.x = -Math.PI / 2;
      scene.add(line);

      // Edge stripes
      const edgeMat1 = new THREE.MeshBasicMaterial({ color: 0xff0000 });
      const edgeMat2 = new THREE.MeshBasicMaterial({ color: 0xffffff });
      for (let i = -1; i <= 1; i += 2) {
        for (let j = 0; j < 50; j++) {
          const color = j % 2 === 0 ? edgeMat1 : edgeMat2;
          const stripe = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 5), color);
          stripe.rotation.x = -Math.PI / 2;
          stripe.position.set(i * 5, 0.02, j * 10 - 250);
          scene.add(stripe);
        }
      }

      // Buildings
      const buildingGeo = new THREE.BoxGeometry(5, 10, 5);
      for (let i = -2; i <= 2; i += 4) {
        for (let j = 0; j < 20; j++) {
          const buildingMat = new THREE.MeshPhongMaterial({ color: 0x222266 + Math.random() * 0x444444 });
          const building = new THREE.Mesh(buildingGeo, buildingMat);
          building.position.set(i * 5, 5, j * 25 - 250);
          buildings.push(building);
          scene.add(building);
        }
      }

      // Street Lights
      const poleGeo = new THREE.CylinderGeometry(0.1, 0.1, 5, 8);
      const lampGeo = new THREE.SphereGeometry(0.2, 8, 8);
      for (let i = -2; i <= 2; i += 4) {
        for (let j = 0; j < 10; j++) {
          const pole = new THREE.Mesh(poleGeo, new THREE.MeshPhongMaterial({ color: 0x555555 }));
          const lamp = new THREE.Mesh(lampGeo, new THREE.MeshBasicMaterial({ color: 0xffffaa }));
          pole.position.set(i * 4.5, 2.5, j * 50 - 250);
          lamp.position.set(i * 4.5, 5, j * 50 - 250);
          streetLights.push(pole, lamp);
          scene.add(pole);
          scene.add(lamp);
        }
      }

      // Traffic Lights
      const lightGeo = new THREE.BoxGeometry(0.5, 1.5, 0.5);
      const redMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
      const greenMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
      for (let i = -2; i <= 2; i += 4) {
        const tLight = new THREE.Mesh(lightGeo, redMat);
        tLight.position.set(i * 3.5, 3, -200);
        trafficLights.push(tLight);
        scene.add(tLight);
      }

      // Load Car
      const loader = new THREE.GLTFLoader();
      loader.load(
        'https://threejs.org/examples/models/gltf/Flamingo.glb', // placeholder model
        function (gltf) {
          car = gltf.scene;
          car.scale.set(0.02, 0.02, 0.02);
          car.position.set(0, 0, 0);
          scene.add(car);
          document.getElementById('loading').style.display = 'none';
        },
        undefined,
        function (error) {
          console.error(error);
          document.getElementById('loading').textContent = 'Error loading car.';
        }
      );

      window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      if (car) {
        car.position.z -= speed * 2;
        camera.position.z = car.position.z + 5;
        camera.lookAt(car.position.x, 1, car.position.z - 5);
      }

      // Move environment
      buildings.forEach(b => {
        b.position.z += speed * 2;
        if (b.position.z > 50) b.position.z -= 500;
      });
      streetLights.forEach(l => {
        l.position.z += speed * 2;
        if (l.position.z > 50) l.position.z -= 500;
      });
      trafficLights.forEach(t => {
        t.position.z += speed * 2;
        if (t.position.z > 50) t.position.z -= 500;
      });

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
